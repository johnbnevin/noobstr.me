<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Noobstr.me - The Read Only Nostr Noobstr Slow Connection Soft Landing Client</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='90' font-size='90'>ü§ô</text></svg>">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' https: data:; connect-src 'self' wss: ws: https:;">
	<style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --bg-color: #ffffff; --text-color: #333333; --accent-orange: #ff6b35; --accent-purple: #7c3aed; --border-color: #e5e7eb; --card-bg: #f9fafb; --input-bg: #ffffff; --button-hover: #f3f4f6; }
        #sortOrder { flex-shrink: 0; min-width: 120px; }
		@media (max-width: 768px) { .top-bar { flex-wrap: wrap; gap: 8px; padding: 8px 12px; } .input-group { width: 100%; min-width: unset; } .controls { flex-wrap: wrap; gap: 8px; } .logo { font-size: 20px; } .note { margin-left: 4px; margin-right: 4px; padding: 12px; } .main-content { padding: 12px 8px; padding-bottom: 120px; } .bottom-bar { font-size: 11px; gap: 4px; } }
		@media (max-width: 480px) { .settings-item { flex-direction: column; } .settings-item input { margin-bottom: 4px; } .settings-item button { align-self: flex-start; min-width: 80px; } .settings-item button[onclick*="remove"] { min-width: 60px; } }
		[data-theme="dark"] { --bg-color: #404040; --text-color: #ffffff; --border-color: #525252; --card-bg: #525252; --input-bg: #525252; --button-hover: #525252; }
		[data-theme="clown"] { --bg-color: #7b1fa2; --text-color: #fff700; --accent-orange: #00ff00; --accent-purple: #ff1493; --border-color: #ff4500; --card-bg: #9400d3; --input-bg: #ff6347; --button-hover: #32cd32; }
		body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: var(--bg-color); color: var(--text-color); transition: all 0.3s ease; }
		input, select { padding: 6px 12px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 14px; }
		input { flex: 1; }
		button { padding: 6px 12px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--input-bg); color: var(--text-color); font-size: 14px; cursor: pointer; transition: background-color 0.2s; min-height: 44px; }
		button:hover { background-color: var(--button-hover); }
		.settings-item button:last-child { background-color: #ef4444 !important; color: white !important; font-size: 12px !important; padding: 4px 8px !important; min-width: 60px !important; min-height: auto !important; }
		.top-bar { position: sticky; top: 0; background-color: var(--bg-color); border-bottom: 1px solid var(--border-color); padding: 8px 12px; z-index: 100; }
        .logo { font-size: 24px; font-weight: bold; color: var(--accent-orange); }
        .input-group { display: flex; gap: 8px; width: 100%; margin-bottom: 8px; }
        .icon-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 16px; border-radius: 4px; }
        .top-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; } .controls-row { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 6px; }
		.controls { display: flex; gap: 12px; padding: 16px; background-color: var(--card-bg); border-bottom: 1px solid var(--border-color); }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-group label { font-size: 14px; font-weight: 500; }
        .main-content { padding: 20px; max-width: 800px; margin: 0 auto; padding-bottom: 100px; }
        .note { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; margin-bottom: 16px; margin-left: 8px; margin-right: 8px; }
		.note-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 14px; color: var(--accent-purple); }
		.note-content { line-height: 1.5; margin-bottom: 8px; word-break: break-word; overflow-wrap: break-word; font-size: 16px; }
		.note-time { font-size: 12px; color: #6b7280; margin-left: 12px; }
		.loading { text-align: center; padding: 20px; color: #6b7280; }
		.error { color: #ef4444; text-align: center; padding: 20px; }
		.bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; background-color: var(--bg-color); border-top: 1px solid var(--border-color); padding: 8px 16px; display: flex; justify-content: space-between; align-items: center; font-size: 12px; min-height: 40px; flex-wrap: wrap; }
		.bottom-links a { color: var(--accent-orange); text-decoration: none; }
		.bottom-links a:hover { text-decoration: underline; }
		.control-group { display: flex; align-items: center; gap: 4px; font-size: 14px; }
		.control-group input[type="checkbox"] { width: auto; margin: 0; }
		.modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; }
		.modal-content { background-color: var(--bg-color); margin: 10% auto; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px; position: relative; }
        .modal h3 { margin-bottom: 16px; color: var(--accent-purple); }
        .settings-section { margin-bottom: 20px; }
        .settings-section h4 { margin-bottom: 8px; font-size: 14px; color: var(--text-color); }
        .settings-item input { flex: 1; }
		.settings-item { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
		.close { position: absolute; right: 10px; top: 10px; font-size: 28px; cursor: pointer; }
		.empty-state { text-align: center; padding: 40px 20px; color: #6b7280; }
		.message-banner { display: none; background-color: var(--accent-orange); color: white; padding: 3px 15px; position: relative; border-bottom: 1px solid var(--border-color); font-size: 12px; line-height: 1.2; }
		.message-banner.show { display: block; }
		.banner-close { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; width: 24px; height: 24px; }
		.banner-close:hover { background-color: rgba(255, 255, 255, 0.2); border-radius: 50%; }
		.console-banner { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 6px; margin: 16px; max-height: none; overflow-y: auto; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 12px; line-height: 1.4; display: none; }
		.console-banner.show { display: block; }
		.console-entry { padding: 2px 8px; border-bottom: 1px solid var(--border-color); font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		.console-entry.warn { color: #f59e0b; }
		.console-entry.error { color: #ef4444; }
		.console-entry.success { color: #10b981; }
		.console-entry:last-child { border-bottom: none; }
		.console-header { padding: 4px 8px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background-color: var(--border-color); }
		.console-content { display: none; max-height: 100px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
		.console-content.expanded { display: block; }
		.lightbox { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 3000; cursor: pointer; }
		.lightbox img { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90vw; max-height: 90vh; cursor: default; }
		.lightbox-close { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; cursor: pointer; user-select: none; }
    </style>
</head>

<body>
	<div class="top-bar">
		<div class="top-row">
			<div class="logo">ü§ô Noobstr</div>
			<div style="display: flex; gap: 8px;">
				<button class="icon-btn" onclick="openSettings()">‚öôÔ∏è</button>
				<button class="icon-btn" onclick="toggleTheme()" id="themeBtn">üåô</button>
			</div>
		</div>
		
		<div class="input-group">
			<input type="text" id="npubInput" placeholder="Enter npub or relay URL...">
			<select id="savedSelector">
				<option value="">Select saved...</option>
			</select>
		</div>
		
		<div id="settingsModal" class="modal">
			<div class="modal-content">
				<span class="close" onclick="closeSettings()">&times;</span>
				<h3>Settings</h3>
				
				<p style="margin-bottom: 20px; color: #6b7280; font-size: 14px; line-height: 1.4;">Save frequently-used npubs and relay URLs here. Once saved, they'll appear in the "Select saved..." dropdown for one-click access. All data is stored locally on your device.</p>
				
				<div class="settings-section">
					<h4>Saved Npubs</h4>
					<div id="npubsList"></div>
					<div class="settings-item">
						<input type="text" id="newNpubName" placeholder="Name">
						<input type="text" id="newNpubValue" placeholder="npub...">
						<button onclick="addNpub()">Add New Npub</button>
					</div>
				</div>

				<div class="settings-section">
					<h4>Saved Relays</h4>
					<div id="relaysList"></div>
					<div class="settings-item">
						<input type="text" id="newRelayName" placeholder="Name">
						<input type="text" id="newRelayValue" placeholder="wss://..." value="wss://">
						<button onclick="addRelay()">Add New Relay</button>
					</div>
				</div>

				<div class="settings-section">
					<h4>Need Help Finding Npubs & Relays?</h4>
					<p style="font-size: 13px; color: #6b7280; margin-bottom: 12px; line-height: 1.4;">
						<strong>Npubs:</strong> Find NOSTRiches with good follow lists at <a href="https://nostr.directory" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange);">nostr.directory</a> <br>
						<strong>Relays:</strong> Find NOSTR public relays at <a href="https://nostr.watch" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange);">nostr.watch</a>
					</p>
					<p style="font-size: 13px; color: #6b7280; margin-bottom: 8px;">
						Ready for the full Nostr experience?  Learn how to post, reply, and zap Bitcoin now:<br>
						<a href="https://nostr.how" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">Nostr.how</a> | <a href="https://nostr.com/ " target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">Nostr.com</a> | <a href="https://grownostr.org/get-started.html" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">GrowNostr.org</a>
					</p>
				</div>
			</div>
		</div>

		<div id="helpModal" class="modal">
			<div class="modal-content">
				<span class="close" onclick="closeHelpModal()">&times;</span>
				<h3>How to Use Noobstr</h3>
				
				<div class="settings-section">
					<h4>Quick Start</h4>
					<p><strong>Just Go!</strong> - Loads a demo feed to see how Nostr works</p>
				</div>

				<div class="settings-section">
					<h4>Advanced Options</h4>
					<p><strong>npub</strong> - Enter someone's npub to see who they follow</p>
					<p><strong>Relay URL</strong> - Enter wss://relay.example.com to see all recent notes from that relay</p>
					<p><strong>Sort Order</strong> - Newest first or oldest first</p>
					<p><strong>Slow Connection</strong> - Check this on old phones or slow internet</p>
				</div>

				<div class="settings-section">
					<h4>Saving Favorites</h4>
					<p>Use the Settings gear to save your favorite npubs and relays for quick access.</p>
				</div>
			</div>
		</div>
		
		<div style="margin-bottom: 4px;">
			<button onclick="loadFeed()" style="background-color: var(--accent-orange); color: white; font-weight: bold; width: 100%;">Just Go!</button>
		</div>
		
		<div class="controls-row">
			<select id="sortOrder">
				<option value="newest">‚Üì Newest</option>
				<option value="oldest">‚Üë Oldest</option>
			</select>
			<label class="control-group">
				<input type="checkbox" id="slowConnection"> Slow connection?
			</label>
		</div>

		<div id="messageBanner" class="message-banner">
			<span id="bannerText"></span>
			<button id="bannerClose" class="banner-close">&times;</button>
		</div>
	</div>

	<div class="main-content">
		<div class="console-banner" id="consoleBanner">
			<div class="console-header" onclick="toggleConsoleLog()">
				<span>üîß Debugger: <span id="latestMessage">Ready...</span></span>
				<span id="expandIcon">‚ñº</span>
			</div>
			<div class="console-content" id="consoleContent"></div>
		</div>

		<div id="feedContainer">
			<div class="empty-state">
				<h3>Welcome, Noobstr!</h3>
				<p>Click the 'Just Go!' button to see what's on NOSTR!</p>
				<p>Enter an npub to see notes from their followers, or enter a relay URL to see notes from that relay.</p>
			</div>
		</div>
	</div>

	<div class="bottom-bar">
		<div class="bottom-links">
			<span>Ready for the full Nostr experience?  Learn how to post, reply, and zap Bitcoin now:<br>
			<a href="https://nostr.how" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">Nostr.how</a> | <a href="https://nostr.com/ " target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">Nostr.com</a> | <a href="https://grownostr.org/get-started.html" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); font-weight: bold;">GrowNostr.org</a></span>
		</div>
		<div class="bottom-links">
			<span><a href="https://coinos.io/pay/jbnevin">Vibecoded with ‚ô•</a></span>
		</div>
	</div>

	<script>
        let currentFeed = [];
        let currentType = null;
        let currentValue = null;
        let isLoading = false;
		let isLookingUpUsernames = false;
		let bannerTimeout = null;
		let imageProcessingQueue = [];
		let isProcessingImages = false;
		let consoleEntries = [];
		const MAX_CONSOLE_ENTRIES = 2500;
		
		// Fallback relays for npub lookups (in order of preference)
		const FALLBACK_RELAYS = [
			'wss://relay.nostr.band',
			'wss://yakihonne.com',
			'wss://nos.lol',
			'wss://coracle.social'
		];

		function logToConsole(message, type = 'log') {
			const sanitizedMessage = typeof message === 'string' ? 
				message.substring(0, 1000).replace(/[<>&"']/g, '') : 
				String(message).substring(0, 1000);
			
			if (console[type]) {
				console[type](sanitizedMessage);
			} else {
				console.log(sanitizedMessage);
			}
			
			const timestamp = new Date().toLocaleTimeString();
			
			// Add to beginning of array with sanitized message
			consoleEntries.unshift({ message: sanitizedMessage, type, timestamp });

			// Properly limit array size to prevent memory leak
			if (consoleEntries.length > MAX_CONSOLE_ENTRIES) {
				consoleEntries.length = MAX_CONSOLE_ENTRIES;
			}
			
			// Show the consolebanner and update latest message
			const consoleBanner = document.getElementById('consoleBanner');
			const latestMessage = document.getElementById('latestMessage');
			
			if (!consoleBanner.classList.contains('show')) {
				consoleBanner.classList.add('show');
			}
			
			// Truncate very long messages in the banner to prevent UI issues
			const truncatedMessage = sanitizedMessage.length > 100 ? sanitizedMessage.slice(0, 100) + '...' : sanitizedMessage;
			latestMessage.textContent = truncatedMessage;
			
			// Only update full log if it's currently expanded (performance improvement)
			const consoleContent = document.getElementById('consoleContent');
			if (consoleContent && consoleContent.classList.contains('expanded')) {
				updateConsoleContent();
			}
		}
		
		function toggleConsoleLog() {
			const consoleContent = document.getElementById('consoleContent');
			const expandIcon = document.getElementById('expandIcon');
			
			if (consoleContent.classList.contains('expanded')) {
				consoleContent.classList.remove('expanded');
				expandIcon.textContent = '‚ñº';
			} else {
				consoleContent.classList.add('expanded');
				expandIcon.textContent = '‚ñ≤';
				updateConsoleContent();
			}
		}

		function updateConsoleContent() {
			const consoleContent = document.getElementById('consoleContent');
			if (!consoleContent.classList.contains('expanded')) return;
			
			// Clear existing content
			while (consoleContent.firstChild) {
				consoleContent.removeChild(consoleContent.firstChild);
			}
			
			// Initial batch size - start small
			const initialBatchSize = 50;
			let currentDisplayCount = 0;
			
			// Create container for entries
			const entriesContainer = document.createElement('div');
			consoleContent.appendChild(entriesContainer);
			
			// Function to load more entries
			const loadMoreEntries = () => {
				const fragment = document.createDocumentFragment();
				const endIndex = Math.min(currentDisplayCount + initialBatchSize, consoleEntries.length);
				
				for (let i = currentDisplayCount; i < endIndex; i++) {
					const entry = consoleEntries[i];
					const div = document.createElement('div');
					div.className = `console-entry ${entry.type || 'log'}`;
					
					const timeSpan = document.createElement('span');
					timeSpan.style.color = '#6b7280';
					timeSpan.textContent = `[${entry.timestamp}] `;
					
					const messageSpan = document.createElement('span');
					const truncatedMessage = entry.message.length > 200 ? entry.message.slice(0, 200) + '...' : entry.message;
					messageSpan.textContent = truncatedMessage;
					
					div.appendChild(timeSpan);
					div.appendChild(messageSpan);
					fragment.appendChild(div);
				}
				
				entriesContainer.appendChild(fragment);
				currentDisplayCount = endIndex;
				
				// Remove load more button if we've shown everything
				const loadMoreBtn = consoleContent.querySelector('.load-more-btn');
				if (loadMoreBtn && currentDisplayCount >= consoleEntries.length) {
					loadMoreBtn.remove();
				}
			};
			
			// Load initial batch
			loadMoreEntries();
			
			// Add "Load More" button if there are more entries
			if (currentDisplayCount < consoleEntries.length) {
				const loadMoreBtn = document.createElement('button');
				loadMoreBtn.className = 'load-more-btn';
				loadMoreBtn.textContent = `Load ${Math.min(initialBatchSize, consoleEntries.length - currentDisplayCount)} more entries (${consoleEntries.length - currentDisplayCount} remaining)`;
				loadMoreBtn.style.cssText = 'width: 100%; padding: 8px; margin: 4px 0; background: var(--card-bg); border: 1px solid var(--border-color); cursor: pointer; font-size: 12px;';
				
				loadMoreBtn.addEventListener('click', () => {
					loadMoreEntries();
					// Update button text
					if (currentDisplayCount < consoleEntries.length) {
						loadMoreBtn.textContent = `Load ${Math.min(initialBatchSize, consoleEntries.length - currentDisplayCount)} more entries (${consoleEntries.length - currentDisplayCount} remaining)`;
					}
				});
				
				consoleContent.appendChild(loadMoreBtn);
			}
		}

		document.addEventListener('DOMContentLoaded', function() {
			// NEW: Validate elements exist before proceeding
			const npubInput = document.getElementById('npubInput');
			const savedSelector = document.getElementById('savedSelector');
			const slowConnection = document.getElementById('slowConnection');
			
			if (!npubInput || !savedSelector || !slowConnection) {
				console.error('Required DOM elements not found');
				return;
			}
			
			loadSettings();
			updateSavedSelector();
			logToConsole('Noobstr initialized! ü§ô');
		});

		// Get relay information according to NIP-11
		async function getRelayInfo(relayUrl) {
			try {
				// Convert WebSocket URL to HTTP for NIP-11 request
				const httpUrl = relayUrl.replace('wss://', 'https://').replace('ws://', 'http://');
				
				logToConsole(`üì° Checking relay info: ${httpUrl}`);
				
				// Set up timeout
				const controller = new AbortController();
				const timeoutId = setTimeout(() => controller.abort(), 2000); // 2 second timeout
				
				const response = await fetch(httpUrl, {
					headers: { 
						'Accept': 'application/nostr+json',
						'User-Agent': 'Noobstr/1.1'
					},
					signal: controller.signal
				});
				
				clearTimeout(timeoutId);
				
				if (!response.ok) {
					logToConsole(`‚ö†Ô∏è Relay ${relayUrl} - no info document (${response.status})`, 'warn');
					return null;
				}
				
				const info = await response.json();
				logToConsole(`‚úÖ Got relay info for ${relayUrl}`, 'success');
				return info;
				
			} catch (error) {
				if (error.name === 'AbortError') {
					logToConsole(`‚è∞ Relay info timeout for ${relayUrl}`, 'warn');
				} else {
					logToConsole(`‚ùå Failed to get relay info for ${relayUrl}: ${error.message}`, 'error');
				}
				return null;
			}
		}

		function validateEventFormat(event) {
			// Check if event exists and is an object
			if (!event || typeof event !== 'object') {
				logToConsole("‚ùå Invalid event: not an object", 'error');
				return false;
			}
			
			// Check required fields exist
			const requiredFields = ['id', 'pubkey', 'created_at', 'kind', 'tags', 'content', 'sig'];
			for (const field of requiredFields) {
				if (!event.hasOwnProperty(field)) {
					logToConsole(`‚ùå Invalid event: missing field '${field}'`, 'error');
					return false;
				}
			}
			
			// Basic format checks
			if (typeof event.id !== 'string' || event.id.length !== 64) {
				logToConsole("‚ùå Invalid event: id should be 64 character hex string", 'error');
				return false;
			}
			
			if (typeof event.pubkey !== 'string' || event.pubkey.length !== 64) {
				logToConsole("‚ùå Invalid event: pubkey should be 64 character hex string", 'error');
				return false;
			}
			
			if (!Number.isInteger(event.created_at) || event.created_at <= 0) {
				logToConsole("‚ùå Invalid event: created_at should be positive integer", 'error');
				return false;
			}
			
			if (!Number.isInteger(event.kind) || event.kind < 0 || event.kind > 65535) {
				logToConsole("‚ùå Invalid event: kind should be integer 0-65535", 'error');
				return false;
			}
			
			if (!Array.isArray(event.tags)) {
				logToConsole("‚ùå Invalid event: tags should be an array", 'error');
				return false;
			}
			
			// Reject overly long content to prevent memory issues
			if (event.content.length > 50000) {
				logToConsole("‚õî Invalid event: content too long (" + event.content.length + " chars)", 'error');
				return false;
			}
			
			if (typeof event.content !== 'string') {
				logToConsole("‚ùå Invalid event: content should be string", 'error');
				return false;
			}
			
			if (typeof event.sig !== 'string' || event.sig.length !== 128) {
				logToConsole("‚ùå Invalid event: sig should be 128 character hex string", 'error');
				return false;
			}
			
			// Check hex format for id, pubkey, and sig
			const hexRegex = /^[a-f0-9]+$/i;
			if (!hexRegex.test(event.id)) {
				logToConsole("‚ùå Invalid event: id contains non-hex characters", 'error');
				return false;
			}
			
			if (!hexRegex.test(event.pubkey)) {
				logToConsole("‚ùå Invalid event: pubkey contains non-hex characters", 'error');
				return false;
			}
			
			if (!hexRegex.test(event.sig)) {
				logToConsole("‚ùå Invalid event: sig contains non-hex characters", 'error');
				return false;
			}
			
			// NEW: Check for unsafe URLs in content
			if (containsUnsafeUrls(event.content)) {
				logToConsole("‚ùå Invalid event: contains unsafe or malformed URLs", 'error');
				return false;
			}
			
			logToConsole("‚úÖ Event format validation passed", 'success');
			return true;
		}

		function npubToPubkey(npub) {
			if (!npub.startsWith('npub')) {
				throw new Error('Not a valid npub');
			}

			// Bech32 alphabet - these are the allowed characters
			const alphabet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
			
			try {
				const data = npub.slice(4);
				
				// Convert each character to its number value
				const decoded = [];
				for (let i = 0; i < data.length; i++) {
					const char = data[i];
					const value = alphabet.indexOf(char);
					if (value === -1) {
						throw new Error('Invalid character in npub');
					}
					decoded.push(value);
				}
				
				// Skip checksum (last 6 characters) and convert from 5-bit to 8-bit
				const payload = decoded.slice(1, -6);
				const pubkeyBytes = convertBits(payload, 5, 8, false);
				
				// Convert to hex string
				const pubkey = pubkeyBytes.map(b => b.toString(16).padStart(2, '0')).join('');
				
				logToConsole("üîë Decoded npub to pubkey: " + pubkey);
				return pubkey;
				
			} catch (error) {
				throw new Error('Invalid npub format: ' + error.message);
			}
		}

		// Helper function to convert between bit groups
		function convertBits(data, fromBits, toBits, pad) {
			let acc = 0;
			let bits = 0;
			const ret = [];
			const maxv = (1 << toBits) - 1;
			
			for (let i = 0; i < data.length; i++) {
				const value = data[i];
				acc = (acc << fromBits) | value;
				bits += fromBits;
				
				while (bits >= toBits) {
					bits -= toBits;
					ret.push((acc >> bits) & maxv);
				}
			}
			
			if (pad && bits > 0) {
				ret.push((acc << (toBits - bits)) & maxv);
			}
			
			return ret;
		}

		function toggleTheme() {
			const body = document.body;
			const currentTheme = body.getAttribute('data-theme') || 'light';
			
			let newTheme;
			if (currentTheme === 'light') {
				newTheme = 'dark';
			} else if (currentTheme === 'dark') {
				newTheme = 'clown';
			} else {
				newTheme = 'light';
			}
			
			body.setAttribute('data-theme', newTheme);
			localStorage.setItem('theme', newTheme);
		}

		// Load saved theme
		const savedTheme = localStorage.getItem('theme') || 'light';
		// NEW: Validate theme value
		const validThemes = ['light', 'dark', 'clown'];
		const safeTheme = validThemes.includes(savedTheme) ? savedTheme : 'light';
		document.body.setAttribute('data-theme', safeTheme);

		// Handle close button click
		document.addEventListener('DOMContentLoaded', function() {
			const bannerClose = document.getElementById('bannerClose');
			// NEW: Check element exists before adding listener
			if (bannerClose) {
				bannerClose.addEventListener('click', hideBanner);
			}
		});

		function loadSettings() {
			// Validate npubs from localStorage
			let npubs = [];
			try {
				const savedNpubs = JSON.parse(localStorage.getItem('savedNpubs') || '[]');
				if (Array.isArray(savedNpubs)) {
					npubs = savedNpubs.filter(item => 
						item && 
						typeof item === 'object' &&  // NEW: Ensure item is an object
						typeof item.name === 'string' && 
						typeof item.value === 'string' && 
						item.value.startsWith('npub1') &&
						item.name.length < 100 &&  // NEW: Limit name length
						item.value.length === 63    // NEW: Validate npub length
					);
				}
			} catch (e) {
				console.log('Invalid npubs data in localStorage, clearing');
				localStorage.removeItem('savedNpubs');
			}
			
			// Validate relays from localStorage  
			let relays = [];
			try {
				const savedRelays = JSON.parse(localStorage.getItem('savedRelays') || '[]');
				if (Array.isArray(savedRelays)) {
					relays = savedRelays.filter(item => 
						item && 
						typeof item === 'object' &&  // NEW: Ensure item is an object
						typeof item.name === 'string' && 
						typeof item.value === 'string' && 
						(item.value.startsWith('wss://') || item.value.startsWith('ws://')) &&
						item.name.length < 100 &&  // NEW: Limit name length
						item.value.length < 500     // NEW: Limit URL length
					);
				}
			} catch (e) {
				console.log('Invalid relays data in localStorage, clearing');
				localStorage.removeItem('savedRelays');
			}
			
			updateSettingsDisplay();
		}

        function saveSettings() {
            updateSavedSelector();
        }

		function updateSavedSelector() {
			const selector = document.getElementById('savedSelector');
			const npubs = JSON.parse(localStorage.getItem('savedNpubs') || '[]');
			const relays = JSON.parse(localStorage.getItem('savedRelays') || '[]');
			
			// Clear selector
			while (selector.firstChild) {
				selector.removeChild(selector.firstChild);
			}

			// Add the default option
			const defaultOption = document.createElement('option');
			defaultOption.value = '';
			defaultOption.textContent = 'Select saved...';
			selector.appendChild(defaultOption);
			
			// Add demo option
			const demoOption = document.createElement('option');
			demoOption.value = 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc';
			demoOption.textContent = 'ü§ô Demo (Default)';
			selector.appendChild(demoOption);
			
			// Add npub section if there are any saved npubs
			if (npubs.length > 0) {
				const npubGroup = document.createElement('optgroup');
				npubGroup.label = 'Saved Npubs';
				
				npubs.forEach(item => {
					const option = document.createElement('option');
					option.value = item.value;
					option.textContent = `üë§ ${item.name}`;
					npubGroup.appendChild(option);
				});
				
				selector.appendChild(npubGroup);
			}
			
			// Add relay section if there are any saved relays  
			if (relays.length > 0) {
				const relayGroup = document.createElement('optgroup');
				relayGroup.label = 'Saved Relays';
				
				relays.forEach(item => {
					const option = document.createElement('option');
					option.value = item.value;
					option.textContent = `‚ö° ${item.name}`;
					relayGroup.appendChild(option);
				});
				
				selector.appendChild(relayGroup);
			}
		}

		function updateSettingsDisplay() {
			const npubs = JSON.parse(localStorage.getItem('savedNpubs') || '[]');
			const relays = JSON.parse(localStorage.getItem('savedRelays') || '[]');
			const npubsList = document.getElementById('npubsList');
			const relaysList = document.getElementById('relaysList');
			
			// Clear existing content using DOM methods
			while (npubsList.firstChild) {
				npubsList.removeChild(npubsList.firstChild);
			}
			while (relaysList.firstChild) {
				relaysList.removeChild(relaysList.firstChild);
			}
			
			// Build npubs list safely
			npubs.forEach((item, index) => {
				const div = document.createElement('div');
				div.className = 'settings-item';
				
				const nameInput = document.createElement('input');
				nameInput.type = 'text';
				nameInput.value = item.name;
				nameInput.readOnly = true;
				
				const valueInput = document.createElement('input');
				valueInput.type = 'text';
				valueInput.value = item.value;
				valueInput.readOnly = true;
				
				const removeBtn = document.createElement('button');
				removeBtn.textContent = 'Remove Npub';
				removeBtn.onclick = () => removeNpub(index);
				
				div.appendChild(nameInput);
				div.appendChild(valueInput);
				div.appendChild(removeBtn);
				npubsList.appendChild(div);
			});
			
			// Build relays list safely
			relays.forEach((item, index) => {
				const div = document.createElement('div');
				div.className = 'settings-item';
				
				const nameInput = document.createElement('input');
				nameInput.type = 'text';
				nameInput.value = item.name;
				nameInput.readOnly = true;
				
				const valueInput = document.createElement('input');
				valueInput.type = 'text';
				valueInput.value = item.value;
				valueInput.readOnly = true;
				
				const removeBtn = document.createElement('button');
				removeBtn.textContent = 'Remove Relay';
				removeBtn.onclick = () => removeRelay(index);
				
				div.appendChild(nameInput);
				div.appendChild(valueInput);
				div.appendChild(removeBtn);
				relaysList.appendChild(div);
			});
		}

		function showMessageBanner(message, duration = 3000) {
			const banner = document.getElementById('messageBanner');
			const bannerText = document.getElementById('bannerText');
			
			// Clear any existing timeout
			if (bannerTimeout) {
				clearTimeout(bannerTimeout);
			}
			
			// Set the message and show banner
			bannerText.textContent = message;
			banner.classList.add('show');
			
			// Auto-hide after duration
			bannerTimeout = setTimeout(() => {
				hideBanner();
			}, duration);
		}

		function hideBanner() {
			const banner = document.getElementById('messageBanner');
			banner.classList.remove('show');
			if (bannerTimeout) {
				clearTimeout(bannerTimeout);
				bannerTimeout = null;
			}
		}

		function processImagesInContent(content, noteElement) {
			// Skip if slow connection mode is enabled
			if (document.getElementById('slowConnection').checked) {
				return content;
			}
			
			// Check if this noteElement already has images processed
			if (noteElement.dataset.imagesProcessed === 'true') {
				return content;
			}
			
			// Look for image URLs in the content
			const imageUrlRegex = /(https:\/\/[^.\s]*\.nostr\.build\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
			const imageUrls = content.match(imageUrlRegex);
			
			if (imageUrls) {
				// Mark this note as having images processed
				noteElement.dataset.imagesProcessed = 'true';
				
				// Add to queue
				imageUrls.forEach(url => {
					imageProcessingQueue.push({ url, noteElement });
					logToConsole(`Added image to queue: ${url.slice(-20)}...`);
				});
				
				// Start processing if not already running
				if (!isProcessingImages) {
					processImageQueue();
				}
			}
			
			return content;
		}
		
		async function processImageQueue() {
			isProcessingImages = true;
			
			while (imageProcessingQueue.length > 0) {
				const batch = [];
				
				// Process up to 3 images at once
				for (let i = 0; i < 3 && imageProcessingQueue.length > 0; i++) {
					const item = imageProcessingQueue.shift();
					batch.push(checkAndRenderImage(item.url, item.noteElement));
				}
				
				// Process this batch
				await Promise.allSettled(batch);
				
				// Small delay to prevent browser lockup on weak devices
				await new Promise(resolve => setTimeout(resolve, 200));
			}
			
			isProcessingImages = false;
		}

		async function checkAndRenderImage(imageUrl, noteElement) {
			try {
				// Strict domain validation - only allow nostr.build
				try {
					const validUrl = new URL(imageUrl);
					if (validUrl.protocol !== 'https:' && validUrl.protocol !== 'http:') {
						logToConsole(`Blocked non-HTTP protocol: ${validUrl.protocol}`, 'warn');
						return;
					}
					
					// Only allow nostr.build domain
					if (!validUrl.hostname.endsWith('nostr.build')) {
						logToConsole(`Blocked non-nostr.build domain: ${validUrl.hostname}`, 'warn');
						return;
					}
				} catch (e) {
					logToConsole(`Malformed image URL blocked`, 'warn');
					return;
				}
				
				logToConsole(`Checking nostr.build image: ${imageUrl.slice(-20)}...`);
				
				// Head request to check file size with timeout
				const controller = new AbortController();
				const timeoutId = setTimeout(() => controller.abort(), 3000);
				
				try {
					const response = await fetch(imageUrl, { 
						method: 'HEAD', 
						signal: controller.signal 
					});
					clearTimeout(timeoutId);
					
					const contentLength = response.headers.get('content-length');
					
					if (contentLength && parseInt(contentLength) > 300000) {
						logToConsole(`Image too large: ${Math.round(contentLength/1000)}kb`, 'warn');
						return;
					}
				} catch (fetchError) {
					clearTimeout(timeoutId);
					logToConsole(`Failed to check image size: ${fetchError.message}`, 'warn');
					return;
				}
				
				// Create image element with timeout and error handling
				const img = document.createElement('img');
				img.style.cssText = `
					max-width: 300px; 
					max-height: 200px; 
					margin: 8px 0; 
					border-radius: 4px; 
					cursor: pointer;
					display: block;
				`;
				
				// Set up timeout to cancel slow loading images
				const loadTimeout = setTimeout(() => {
					img.src = ''; // Cancel loading
					img.remove(); // Remove from DOM
					logToConsole(`Image load timeout: ${imageUrl.slice(-20)}...`, 'warn');
				}, 5000); // 5 second timeout for actual image loading
				
				img.onload = () => {
					clearTimeout(loadTimeout);
					logToConsole(`Image rendered: ${imageUrl.slice(-20)}.`, 'success');
				};
				
				img.onerror = () => {
					clearTimeout(loadTimeout);
					img.remove(); // Remove broken image from DOM
					logToConsole(`Image not loaded: ${imageUrl.slice(-20)}...`, 'error');
				};
				
				img.onclick = () => openLightbox(imageUrl);
				
				// Start loading after setting up handlers
				img.src = imageUrl;
				noteElement.appendChild(img);
				
			} catch (error) {
				logToConsole(`Failed to check image: ${error.message}`, 'error');
			}
		}

		function openLightbox(imageUrl) {
			// Validate image URL before opening lightbox
			try {
				const url = new URL(imageUrl);
				if (url.protocol !== 'https:' && url.protocol !== 'http:') {
					return; // Skip unsafe protocols
				}
			} catch (e) {
				return; // Skip malformed URLs
			}
			
			const lightbox = document.createElement('div');
			lightbox.className = 'lightbox';
			
			const img = document.createElement('img');
			img.src = imageUrl;
			img.onclick = (e) => e.stopPropagation(); // Prevent closing when clicking image
			
			const closeBtn = document.createElement('span');
			closeBtn.className = 'lightbox-close';
			closeBtn.innerHTML = '&times;';
			
			// Create the escape handler function
			const escapeHandler = (e) => {
				if (e.key === 'Escape') {
					closeLightbox(lightbox, escapeHandler);
				}
			};
			
			// Create a unified close function that always cleans up properly
			const closeLightboxSafely = () => {
				closeLightbox(lightbox, escapeHandler);
			};
			
			// Assign the same cleanup function to all close triggers
			closeBtn.onclick = closeLightboxSafely;
			lightbox.onclick = closeLightboxSafely;
			
			lightbox.appendChild(img);
			lightbox.appendChild(closeBtn);
			
			document.body.appendChild(lightbox);
			lightbox.style.display = 'block';
			
			// Add escape key listener
			document.addEventListener('keydown', escapeHandler);
		}

		function closeLightbox(lightbox, escapeHandler) {
			// Remove the escape key listener to prevent memory leak
			if (escapeHandler) {
				document.removeEventListener('keydown', escapeHandler);
			}
			
			lightbox.style.display = 'none';
			document.body.removeChild(lightbox);
		}

		function containsUnsafeUrls(content) {
			// Define allowed protocols - only very common, safe ones
			const SAFE_PROTOCOLS = new Set([
				'http:', 'https:', 'ws:', 'wss:', 
				'ftp:', 'ftps:', 'mailto:', 'tel:', 'sms:',
				'nostr:'  // Add nostr protocol as safe
			]);
			
			// More comprehensive URL regex
			const urlRegex = /(https?:\/\/[^\s<>"\[\]{}|\\^`]+)|([a-zA-Z][a-zA-Z0-9+.-]*:\/\/[^\s<>"\[\]{}|\\^`]+)|([a-zA-Z][a-zA-Z0-9+.-]*:[^\s<>"\[\]{}|\\^`\s]+)/gi;
			
			const urls = content.match(urlRegex);
			
			if (!urls) {
				return false; // No URLs found, content is safe
			}
			
			logToConsole(`Checking ${urls.length} URLs in note for safety`);
			
			for (const urlString of urls) {
				try {
					// Handle special cases that don't need URL constructor
					if (urlString.startsWith('mailto:') || 
						urlString.startsWith('tel:') || 
						urlString.startsWith('sms:') ||
						urlString.startsWith('nostr:')) {
						continue; // These are safe
					}
					
					const url = new URL(urlString);
					
					if (!SAFE_PROTOCOLS.has(url.protocol)) {
						logToConsole(`Unsafe protocol detected: ${url.protocol} in URL: ${urlString.slice(0, 50)}...`, 'warn');
						return true; // Found unsafe URL
					}
					
					// Additional safety checks for dangerous protocols
					if (url.protocol === 'javascript:' || 
						url.protocol === 'data:' || 
						url.protocol === 'file:' || 
						url.protocol === 'blob:' ||
						url.protocol === 'vbscript:') {
						logToConsole(`Potentially malicious protocol blocked: ${url.protocol}`, 'warn');
						return true;
					}
					
				} catch (error) {
					// If URL constructor fails, it's malformed
					logToConsole(`Malformed URL detected: ${urlString.slice(0, 50)}...`, 'warn');
					return true;
				}
			}
			
			logToConsole(`All URLs in note are safe`, 'success');
			return false; // All URLs are safe
		}

		// Replace all URLs with pretty shortened versions based on content type
		function prettifyAllLinks(text) {
			const urlRegex = /(https?:\/\/[^\s]+)/gi;
			
			return text.replace(urlRegex, function(fullUrl) {
				try {
					const urlObj = new URL(fullUrl);
					
					// SECURITY: Only allow safe protocols
					if (urlObj.protocol !== 'https:' && urlObj.protocol !== 'http:') {
						logToConsole(`Blocked unsafe URL protocol: ${urlObj.protocol}`, 'warn');
						return fullUrl; // Return as plain text, don't make it a link
					}
					
					const domain = urlObj.hostname.replace(/^www\./, '');
					const path = urlObj.pathname.toLowerCase();
					const searchParams = urlObj.search.toLowerCase();
					
					let linkType = 'web'; // default
					
					// Video platforms
					if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
						linkType = 'video';
					} else if (domain.includes('rumble.com') || domain.includes('vimeo.com') || domain.includes('twitch.tv')) {
						linkType = 'video';
					} else if (domain.includes('tiktok.com') || domain.includes('instagram.com') && path.includes('/reel')) {
						linkType = 'video';
					}
					
					// Music platforms
					else if (domain.includes('spotify.com') || domain.includes('tidal.com') || domain.includes('apple.com') && path.includes('music')) {
						linkType = 'music';
					} else if (domain.includes('soundcloud.com') || domain.includes('bandcamp.com')) {
						linkType = 'music';
					}
					
					// Social media
					else if (domain.includes('twitter.com') || domain.includes('x.com')) {
						linkType = 'social';
					} else if (domain.includes('facebook.com') || domain.includes('instagram.com') || domain.includes('linkedin.com')) {
						linkType = 'social';
					}
					
					// Media files (keep your existing logic)
					else if (fullUrl.match(/\.(mp4|mov|avi|mkv|webm)$/i)) {
						linkType = 'video';
					} else if (fullUrl.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) {
						linkType = 'image';
					} else if (fullUrl.match(/\.(pdf|doc|docx)$/i)) {
						linkType = 'document';
					} else if (fullUrl.match(/\.(mp3|wav|flac|m4a)$/i)) {
						linkType = 'audio';
					}
					
					// News/articles
					else if (domain.includes('reddit.com') || domain.includes('news.') || domain.includes('cnn.com') || domain.includes('bbc.')) {
						linkType = 'news';
					}
					
					const safeUrl = fullUrl.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
					return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" style="color: var(--accent-orange); text-decoration: underline;">${domain}/[${linkType}]</a>`;
					
				} catch (e) {
					return fullUrl; // Return original if URL parsing fails
				}
			});
		}

		function addNpub() {
			const name = document.getElementById('newNpubName').value.trim();
			const value = document.getElementById('newNpubValue').value.trim();
			
			if (!name && !value) {
				showMessageBanner("Please enter both a name and npub", 3000);
				return;
			}
			if (!name) {
				showMessageBanner("Please enter a name for this npub", 3000);
				return;
			}
			if (!value) {
				showMessageBanner("Please enter an npub value", 3000);
				return;
			}
			
			// NEW: Validate npub format
			if (!value.startsWith('npub1') || value.length !== 63) {
				showMessageBanner("Invalid npub format. Must start with 'npub1' and be 63 characters long.", 4000);
				return;
			}
			
			// NEW: Check for valid bech32 characters only
			const validChars = /^npub1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]+$/;
			if (!validChars.test(value)) {
				showMessageBanner("Invalid npub: contains invalid characters", 3000);
				return;
			}
			
			// NEW: Sanitize the name to prevent XSS
			const sanitizedName = name.replace(/[<>&"']/g, '').substring(0, 50);
			if (sanitizedName !== name) {
				showMessageBanner("Name was sanitized (removed special characters/length)", 3000);
			}
			
			const npubs = JSON.parse(localStorage.getItem('savedNpubs') || '[]');
			npubs.push({ name: sanitizedName, value });
			localStorage.setItem('savedNpubs', JSON.stringify(npubs));
			
			document.getElementById('newNpubName').value = '';
			document.getElementById('newNpubValue').value = '';
			
			updateSettingsDisplay();
			updateSavedSelector();
			
			showMessageBanner(`Saved npub: ${sanitizedName}`, 2000);
		}

		function addRelay() {
			const name = document.getElementById('newRelayName').value.trim();
			const value = document.getElementById('newRelayValue').value.trim();
			
			if (!name && !value) {
				showMessageBanner("Please enter both a name and relay URL", 3000);
				return;
			}
			if (!name) {
				showMessageBanner("Please enter a name for this relay", 3000);
				return;
			}
			if (!value) {
				showMessageBanner("Please enter a relay URL", 3000);
				return;
			}
			
			// NEW: Validate relay URL format
			if (!value.startsWith('wss://') && !value.startsWith('ws://')) {
				showMessageBanner("Invalid relay URL. Must start with 'wss://' or 'ws://'", 3000);
				return;
			}
			
			// NEW: Validate URL structure using URL constructor
			try {
				const url = new URL(value);
				
				// Ensure protocol is WebSocket
				if (url.protocol !== 'wss:' && url.protocol !== 'ws:') {
					showMessageBanner("Invalid protocol. Use wss:// or ws://", 3000);
					return;
				}
				
				// Ensure hostname exists and looks reasonable
				if (!url.hostname || url.hostname.length < 3 || url.hostname.includes(' ')) {
					showMessageBanner("Invalid hostname in relay URL", 3000);
					return;
				}
				
				// Block obvious local/private networks for security
				if (url.hostname === 'localhost' || url.hostname === '127.0.0.1' || 
					url.hostname.startsWith('192.168.') || url.hostname.startsWith('10.') ||
					url.hostname.startsWith('172.')) {
					showMessageBanner("Local/private network relays not allowed", 3000);
					return;
				}
				
			} catch (error) {
				showMessageBanner("Invalid relay URL format", 3000);
				return;
			}
			
			// NEW: Sanitize the name to prevent XSS
			const sanitizedName = name.replace(/[<>&"']/g, '').substring(0, 50);
			if (sanitizedName !== name) {
				showMessageBanner("Name was sanitized (removed special characters/length)", 3000);
			}
			
			const relays = JSON.parse(localStorage.getItem('savedRelays') || '[]');
			relays.push({ name: sanitizedName, value });
			localStorage.setItem('savedRelays', JSON.stringify(relays));
			
			document.getElementById('newRelayName').value = '';
			document.getElementById('newRelayValue').value = '';
			
			updateSettingsDisplay();
			updateSavedSelector();
			
			showMessageBanner(`Saved relay: ${sanitizedName}`, 2000);
		}

        function removeNpub(index) {
            const npubs = JSON.parse(localStorage.getItem('savedNpubs') || '[]');
            npubs.splice(index, 1);
            localStorage.setItem('savedNpubs', JSON.stringify(npubs));
            updateSettingsDisplay();
            updateSavedSelector();
        }

        function removeRelay(index) {
            const relays = JSON.parse(localStorage.getItem('savedRelays') || '[]');
            relays.splice(index, 1);
            localStorage.setItem('savedRelays', JSON.stringify(relays));
            updateSettingsDisplay();
            updateSavedSelector();
        }

        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            updateSettingsDisplay();
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Feed management
        function getInputValue() {
            const input = document.getElementById('npubInput').value.trim();
            const selector = document.getElementById('savedSelector').value;
            return input || selector;
        }

        function determineInputType(value) {
            if (value.startsWith('npub')) return 'npub';
            if (value.startsWith('wss://') || value.startsWith('ws://')) return 'relay';
            return null;
        }

		function loadFeed() {
			logToConsole('Load button clicked!');
			const value = getInputValue();
			
			// If no input, use default feed
			if (!value) {
				logToConsole('No input found - loading default feed for beginners!');
				
				const defaultNpub = 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc';
				
				currentType = 'npub';
				currentValue = defaultNpub;
				
				// Clear feed and start loading
				currentFeed = [];
				displayFeed([]);
				
				loadNpubFeed(defaultNpub);
				
				// Show info about what they're viewing (only if no alert exists yet)
				setTimeout(() => {
					const container = document.getElementById('feedContainer');
					const existingAlert = container.querySelector('[data-demo-alert="true"]');
					if (!existingAlert) {
						showDefaultFeedInfo();
					}
				}, 2000);
				return;
			}

			const type = determineInputType(value);
			logToConsole('Input type detected: ' + (type || 'invalid') + ' for: ' + value);
			if (!type) {
				alert('Please enter a valid npub (starts with npub) or relay URL (starts with wss://)');
				return;
			}

			// Clear feed when switching types or values
			if (currentType !== type || currentValue !== value) {
				currentFeed = [];
				displayFeed([]);
			}

			currentType = type;
			currentValue = value;

			if (type === 'npub') {
				loadNpubFeed(value);
			} else {
				loadRelayFeed(value);
			}
		}

		function createSecureMessageHandler(feedType, realNotes, relay, someFollows, since, currentLimit) {
			return function(event) {
				// Sanitize and limit log data to prevent log injection
				const logData = typeof event.data === 'string' ? 
					event.data.substring(0, 200).replace(/[<>&"']/g, '') : 
					'[non-string data]';
				logToConsole("üì® RAW MESSAGE FROM RELAY: " + logData);
				
				try {
					// Size limit check before parsing
					if (typeof event.data === 'string' && event.data.length > 100000) {
						logToConsole("üö´ Message too large, rejecting", 'error');
						return;
					}
					
					const message = JSON.parse(event.data);
					
					// Strict message structure validation
					if (!Array.isArray(message) || message.length < 2) {
						logToConsole("üö´ Invalid message format: not a proper array with minimum elements", 'error');
						return;
					}
					
					// Validate message type is string and allowed
					const messageType = message[0];
					if (typeof messageType !== 'string') {
						logToConsole("üö´ Invalid message type: not a string", 'error');
						return;
					}
					
					// Only allow expected Nostr message types
					const allowedTypes = ['EVENT', 'EOSE', 'NOTICE', 'OK'];
					if (!allowedTypes.includes(messageType)) {
						logToConsole("üö´ Unknown message type: " + messageType, 'error');
						return;
					}
					
					// Validate subscription ID format
					if (messageType === 'EVENT' || messageType === 'EOSE') {
						if (typeof message[1] !== 'string' || message[1].length > 100) {
							logToConsole("üö´ Invalid subscription ID", 'error');
							return;
						}
					}
					
					// Sanitize log output to prevent log injection
					const sanitizedMessage = JSON.stringify(message).substring(0, 300).replace(/[<>&"']/g, '');
					logToConsole("üì® PARSED MESSAGE: " + sanitizedMessage);
					logToConsole("üì® MESSAGE TYPE: " + messageType);
					
					if (messageType === "EVENT") {
						// Validate EVENT message structure
						if (message.length < 3) {
							logToConsole("üö´ EVENT message missing required elements", 'error');
							return;
						}
						
						const noteData = message[2];
						
						// Strict event data validation
						if (!noteData || typeof noteData !== 'object') {
							logToConsole("üö´ EVENT data is not an object", 'error');
							return;
						}
						
						// Validate all required fields exist and have correct types
						const requiredStringFields = ['id', 'pubkey', 'content', 'sig'];
						for (const field of requiredStringFields) {
							if (!noteData.hasOwnProperty(field) || typeof noteData[field] !== 'string') {
								logToConsole("üö´ EVENT missing or invalid field: " + field, 'error');
								return;
							}
						}
						
						// Validate numeric fields
						if (!noteData.hasOwnProperty('created_at') || !Number.isInteger(noteData.created_at)) {
							logToConsole("üö´ EVENT invalid created_at", 'error');
							return;
						}
						
						if (!noteData.hasOwnProperty('kind') || !Number.isInteger(noteData.kind)) {
							logToConsole("üö´ EVENT invalid kind", 'error');
							return;
						}
						
						// Validate tags is array
						if (!noteData.hasOwnProperty('tags') || !Array.isArray(noteData.tags)) {
							logToConsole("üö´ EVENT invalid tags", 'error');
							return;
						}
						
						// Size limits on critical fields
						if (noteData.id.length !== 64 || noteData.pubkey.length !== 64 || noteData.sig.length !== 128) {
							logToConsole("üö´ EVENT invalid field lengths", 'error');
							return;
						}
						
						if (noteData.content.length > 50000) {
							logToConsole("üö´ EVENT content too long", 'error');
							return;
						}
						
						// Validate hex format for critical fields
						const hexRegex = /^[a-f0-9]+$/i;
						if (!hexRegex.test(noteData.id) || !hexRegex.test(noteData.pubkey) || !hexRegex.test(noteData.sig)) {
							logToConsole("üö´ EVENT invalid hex format", 'error');
							return;
						}
						
						// Validate kind range
						if (noteData.kind < 0 || noteData.kind > 65535) {
							logToConsole("üö´ EVENT kind out of range", 'error');
							return;
						}
						
						// Validate timestamp is reasonable (not too far in past/future)
						const now = Math.floor(Date.now() / 1000);
						if (noteData.created_at < now - (365 * 24 * 60 * 60) || noteData.created_at > now + (24 * 60 * 60)) {
							logToConsole("üö´ EVENT timestamp unreasonable", 'error');
							return;
						}
						
						// Validate tags array structure
						if (noteData.tags.length > 1000) {
							logToConsole("üö´ EVENT too many tags", 'error');
							return;
						}
						
						for (const tag of noteData.tags) {
							if (!Array.isArray(tag) || tag.length === 0 || tag.length > 10) {
								logToConsole("üö´ EVENT invalid tag structure", 'error');
								return;
							}
							for (const tagElement of tag) {
								if (typeof tagElement !== 'string' || tagElement.length > 1000) {
									logToConsole("üö´ EVENT invalid tag element", 'error');
									return;
								}
							}
						}
						
						// VALIDATE EVENT FIRST with existing function
						if (!validateEventFormat(noteData)) {
							logToConsole("üö´ Rejecting invalid event from relay", 'error');
							return;
						}
						
						const isReply = noteData.tags && noteData.tags.some(tag => tag[0] === 'e');
						if (isReply) {
							logToConsole("‚≠ê Skipping reply note");
							return;
						}
						logToConsole("üìù Got a real note: " + noteData.content.slice(0, 50) + "...");
						
						const prettyNote = {
							id: noteData.id,
							pubkey: noteData.pubkey,
							author: noteData.pubkey.slice(0, 8) + "...",
							npub: "npub" + noteData.pubkey.slice(-8),
							content: noteData.content,
							timestamp: noteData.created_at,
							source: feedType === 'npub' ? 'real relay data! üéâ' : 'real relay data!'
						};

						// Check if we already have this note
						const existingNote = realNotes.find(note => note.id === noteData.id);
						if (!existingNote) {
							realNotes.push(prettyNote);
						}
					}
					
					// Handle follows list (only for npub feeds)
					if (feedType === 'npub' && messageType === "EVENT" && message.length >= 3 && message[2] && typeof message[2] === 'object' && message[2].kind === 3) {
						const followsEvent = message[2];
						logToConsole("üìã Got follows list!");
						
						const followedPubkeys = [];
						followsEvent.tags.forEach(tag => {
							if (tag[0] === 'p' && tag.length >= 2 && typeof tag[1] === 'string' && tag[1].length === 64) {
								followedPubkeys.push(tag[1]);
							}
						});
						
						logToConsole("ü§ù This person follows " + followedPubkeys.length + " people");
						logToConsole("üìù Now getting notes from their follows...");
						
						const maxFollowsToCheck = document.getElementById('slowConnection').checked ? 100 : 500;
						someFollows.length = 0; // Clear array
						someFollows.push(...followedPubkeys.slice(0, maxFollowsToCheck));
						since = Math.floor(Date.now() / 1000) - (24 * 60 * 60);
						
						const notesRequest = [
							"REQ",
							"get-notes",
							{
								"kinds": [1],
								"authors": someFollows,
								"since": since,
								"limit": 100
							}
						];
						
						logToConsole("üì§ Asking for notes from " + someFollows.length + " follows (max " + maxFollowsToCheck + ")");
						relay.send(JSON.stringify(notesRequest));
					}
					
					if (messageType === "EOSE") {
						// Validate EOSE message has subscription ID
						if (message.length < 2 || typeof message[1] !== 'string') {
							logToConsole("üö´ Invalid EOSE message format", 'error');
							return;
						}
						
						logToConsole("‚Ñπ EOSE for subscription: " + message[1]);
						
						if (message[1] === "get-follows") {
							logToConsole("‚úÖ Done getting follows list");
						}
						
						if (message[1] === "get-notes" || message[1] === "get-more-notes" || message[1] === "my-sub-id" || message[1] === "get-more-relay-notes") {
							logToConsole("‚úÖ Done getting notes", 'success');
							logToConsole("üìä Current count: " + realNotes.length + " notes");
							
							if (realNotes.length < 100 && currentLimit < 2000) {
								logToConsole("üî• Need more notes, increasing limit and trying again");
								currentLimit = currentLimit + 200;
								
								const requestId = feedType === 'npub' ? "get-more-notes" : "get-more-relay-notes";
								const notesRequest = [
									"REQ",
									requestId,
									{
										"kinds": [1],
										"authors": feedType === 'npub' ? someFollows : undefined,
										"since": since,
										"limit": currentLimit
									}
								];
								
								// Remove undefined properties
								if (feedType !== 'npub') {
									delete notesRequest[2].authors;
								}
								
								relay.send(JSON.stringify(notesRequest));
								return;
							}
							
							currentFeed = realNotes;
							displayFeed(realNotes);
							setLoading(false);
							relay.close();
							logToConsole("üìå Connection closed - stopping at " + realNotes.length + " notes");
						}
					}
					
					if (messageType === "NOTICE") {
						// Validate NOTICE message and sanitize content
						if (message.length >= 2 && typeof message[1] === 'string' && message[1].length < 1000) {
							const sanitizedNotice = message[1].substring(0, 200).replace(/[<>&"']/g, '');
							logToConsole("üì¢ RELAY NOTICE: " + sanitizedNotice);
							showError("Relay notice: " + sanitizedNotice);
						} else {
							logToConsole("üö´ Invalid NOTICE message format", 'error');
						}
					}
					
				} catch (e) {
					// Don't log the full error message (could contain sensitive data)
					logToConsole("üí• FAILED TO PARSE MESSAGE: Invalid JSON or processing error", 'error');
				}
			};
		}

		async function loadNpubFeed(npub) {
			if (isLoading) return;
			
			setLoading(true);
			
			const realNotes = [];
			let someFollows = [];
			let since = 0;
			let topLevelNotesCount = 0;
			const targetNotes = 100;
			let currentLimit = 200; // Start with this many notes per request
			
			try {
				logToConsole("üîç Looking up follows for: " + npub);

				// Convert npub to pubkey, or use default if it's the default npub
				let realPubkey;
				if (npub === 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc') {
					// Use hardcoded pubkey for default demo
					realPubkey = "61cb31a85d31f297e324e15797c24403233cbbb1c9d5b78db5b1331cdb24bb15";
				} else {
					// Convert user's npub to pubkey
					try {
						realPubkey = npubToPubkey(npub);
					} catch (error) {
						showError('Failed to load npub feed: ' + error.message);
						setLoading(false);
					}
				}

				logToConsole("üîë Using pubkey: " + realPubkey);
				
				const relay = await connectToRelay();

				// Store this working relay connection for potential reuse
				window.lastWorkingRelay = relay;
				window.lastRelayUrl = relay.url;

				// Relay is already connected, so send the request immediately
				logToConsole("üéâ Connected to get follows list", 'success');

				const followsRequest = [
					"REQ",
					"get-follows",
					{
						"kinds": [3],
						"authors": [realPubkey],
						"limit": 1
					}
				];

				logToConsole("üì§ Asking for follows list...");
				relay.send(JSON.stringify(followsRequest));

				relay.onmessage = createSecureMessageHandler('npub', realNotes, relay, someFollows, since, currentLimit);

				relay.onerror = function(error) {
					// Clear the cached connection if it fails
					window.lastWorkingRelay = null;
					window.lastRelayUrl = null;
					showError('Relay connection lost during operation.');
					setLoading(false);
				};
				
			} catch (error) {
				showError('Failed to load npub feed: ' + error.message);
				setLoading(false);
			}
		}

		function tryConnectToSingleRelay(relayUrl) {
			return new Promise((resolve, reject) => {
				// NEW: Validate URL before connecting
				try {
					const url = new URL(relayUrl);
					if (url.protocol !== 'wss:' && url.protocol !== 'ws:') {
						reject(new Error('Invalid protocol'));
						return;
					}
				} catch (e) {
					reject(new Error('Invalid URL format'));
					return;
				}
				
				const relay = new WebSocket(relayUrl);
				let timeoutId = null;
				let isResolved = false;
				
				const cleanup = () => {
					if (timeoutId) {
						clearTimeout(timeoutId);
						timeoutId = null;
					}
				};
				
				const resolveOnce = (value) => {
					if (!isResolved) {
						isResolved = true;
						cleanup();
						resolve(value);
					}
				};
				
				const rejectOnce = (error) => {
					if (!isResolved) {
						isResolved = true;
						cleanup();
						if (relay.readyState === WebSocket.CONNECTING || relay.readyState === WebSocket.OPEN) {
							relay.close();
						}
						reject(error);
					}
				};
				
				timeoutId = setTimeout(() => {
					logToConsole(`Connection timeout for ${relayUrl}`, 'warn');
					rejectOnce(new Error(`Connection timeout after 5 seconds`));
				}, 5000);
				
				relay.onopen = function() {
					logToConsole(`WebSocket opened successfully: ${relayUrl}`, 'success');
					resolveOnce(relay);
				};
				
				relay.onerror = function(error) {
					const errorMsg = error.message || error.type || 'Unknown WebSocket error';
					logToConsole(`WebSocket error for ${relayUrl}: ${errorMsg}`, 'error');
					rejectOnce(new Error(`WebSocket connection failed: ${errorMsg}`));
				};
				
				relay.onclose = function(event) {
					if (!isResolved) {
						const reason = event.reason || `Code ${event.code}`;
						logToConsole(`WebSocket closed unexpectedly for ${relayUrl}: ${reason}`, 'warn');
						rejectOnce(new Error(`Connection closed: ${reason}`));
					}
				};
			});
		}

		// Try connecting to primary relay, then fallbacks if it fails
		async function connectToRelay() {
			const PRIMARY_RELAY = 'wss://relay.damus.io';
			const allRelays = [PRIMARY_RELAY, ...FALLBACK_RELAYS];
			
			for (let i = 0; i < allRelays.length; i++) {
				const relayUrl = allRelays[i];
				logToConsole(`Attempting connection ${i + 1}/${allRelays.length}: ${relayUrl}`);
				
				// Basic check for hardcoded relays (don't wait long, just try)
				const relayInfo = await getRelayInfo(relayUrl);
				if (relayInfo) {
					logToConsole(`Relay ${relayUrl}: ${relayInfo.name || 'unnamed'} (${relayInfo.software || 'unknown software'})`);
				}
				
				try {
					const relay = await tryConnectToSingleRelay(relayUrl);
					logToConsole(`Successfully connected to: ${relayUrl}`, 'success');
					return relay;
				} catch (error) {
					logToConsole(`Failed to connect to ${relayUrl}: ${error.message}`, 'error');
					
					if (i === allRelays.length - 1) {
						throw new Error('All relays failed to connect');
					}
				}
			}
		}

		async function loadRelayFeed(relayUrl) {
			if (isLoading) return;
			
			setLoading(true);
			
			let currentLimit = 200; // Start with this many notes per request
			const realNotes = []; 			
			let since = 0; 
			
			try {
				logToConsole("User relay detected - performing comprehensive checks...");
				
				// Comprehensive relay validation for user-entered relays
				const relayInfo = await getRelayInfo(relayUrl);
				
				if (relayInfo) {
					logToConsole(`Relay Info: ${relayInfo.name || 'Unnamed'}`);
					logToConsole(`Description: ${relayInfo.description || 'No description'}`);
					logToConsole(`Software: ${relayInfo.software || 'Unknown'} ${relayInfo.version || ''}`);
					
					// Show relay info in banner instead of separate element
					const relayName = relayInfo.name || 'Unnamed Relay';
					const relayDesc = relayInfo.description || 'No description';
					showMessageBanner(`Connected to relay: ${relayName} - ${relayDesc}`, 8000);
					
					// Check supported NIPs
					if (relayInfo.supported_nips && relayInfo.supported_nips.length > 0) {
						logToConsole(`Supported NIPs: [${relayInfo.supported_nips.join(', ')}]`);
						
						// Check if it supports basic requirements
						if (!relayInfo.supported_nips.includes(1)) {
							showMessageBanner("WARNING: This relay doesn't support basic text notes (NIP-01)", 5000);
						}
					} else {
						logToConsole("No NIP information provided by relay", 'warn');
					}
					
					// Check limitations
					if (relayInfo.limitation) {
						const limits = relayInfo.limitation;
						if (limits.payment_required) {
							showMessageBanner("INFO: This relay requires payment", 3000);
						}
						if (limits.auth_required) {
							showMessageBanner("INFO: This relay requires authentication", 3000);
						}
						if (limits.max_limit && limits.max_limit < 100) {
							showMessageBanner(`INFO: This relay limits queries to ${limits.max_limit} events`, 3000);
						}
					}
					
				} else {
					showMessageBanner("WARNING: Could not get information about this relay", 4000);
				}
				
				logToConsole("Attempting WebSocket connection to: " + relayUrl);
				
				const relay = new WebSocket(relayUrl);

				
				relay.onopen = function() {
					logToConsole("Connected to relay: " + relayUrl);
					
					since = Math.floor(Date.now() / 1000) - (24 * 60 * 60); // Always 24 hours (remove const)
					const requestMessage = [
						"REQ",
						"my-sub-id",
						{
							"kinds": [1],
							"since": since,
							"limit": 1000  // Fixed at 1000 notes max (current setting)
						}
					];
					
					logToConsole("Asking relay for notes");
					relay.send(JSON.stringify(requestMessage));
				};
				
				relay.onmessage = createSecureMessageHandler('relay', realNotes, relay, [], since, currentLimit);
				
				relay.onerror = function(error) {
					logToConsole("Connection error: " + error);
					showError('Failed to connect to relay');
					setLoading(false);
				};
				
			} catch (error) {
				showError('Failed to load relay feed: ' + error.message);
				setLoading(false);
			}
		}

		function displayFeed(notes, fetchUsernames = true) {
			const container = document.getElementById('feedContainer');
			const sortOrder = document.getElementById('sortOrder').value;
			
			// Limit feed size to prevent memory issues
			const MAX_FEED_SIZE = 500;
			if (notes.length > MAX_FEED_SIZE) {
				logToConsole(`Feed limited to ${MAX_FEED_SIZE} notes (was ${notes.length})`, 'warn');
				notes = notes.slice(0, MAX_FEED_SIZE);
			}
			
			// Clear container but preserve demo alert if we're still on demo feed
			const existingDemoAlert = container.querySelector('[data-demo-alert="true"]');
			const shouldPreserveDemoAlert = existingDemoAlert && 
				currentType === 'npub' && 
				currentValue === 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc';

			// Fast clear with fallback for older browsers
			if (container.replaceChildren) {
				// Modern browsers (2020+) - fast and secure
				container.replaceChildren();
				if (shouldPreserveDemoAlert) {
					container.appendChild(existingDemoAlert);
				}
			} else {
				// Fallback for older browsers - slower but works everywhere
				while (container.firstChild) {
					container.removeChild(container.firstChild);
				}
				if (shouldPreserveDemoAlert) {
					container.appendChild(existingDemoAlert);
				}
			}
			
			// Clear image processing state
			imageProcessingQueue = [];
			isProcessingImages = false;
			
			// Prevent multiple simultaneous username fetches
			if (fetchUsernames && isLookingUpUsernames) {
				fetchUsernames = false;
				logToConsole("Skipping username fetch - already in progress");
			}
			
			// Check if we might have hit the limit and add warning AFTER clearing
			if (notes.length >= 500) {
				const warning = document.createElement('div');
				warning.style.cssText = 'background: #fef3c7; border: 1px solid #f59e0b; padding: 8px; margin-bottom: 16px; border-radius: 6px; font-size: 14px;';
				warning.textContent = 'Warning: Showing 1000+ notes (may be incomplete). This relay has lots of activity!';
				container.appendChild(warning);
			}
			
			if (notes.length === 0) {
				const emptyDiv = document.createElement('div');
				emptyDiv.className = 'empty-state';
				const emptyP = document.createElement('p');
				emptyP.textContent = 'No notes found for the selected criteria.';
				emptyDiv.appendChild(emptyP);
				container.appendChild(emptyDiv);
				return;
			}
			
			// Sort notes
			const sortedNotes = [...notes].sort((a, b) => {
				return sortOrder === 'newest' ? b.timestamp - a.timestamp : a.timestamp - b.timestamp;
			});
			
			sortedNotes.forEach(note => {
				const noteElement = document.createElement('div');
				noteElement.className = 'note';
				
				const date = new Date(note.timestamp * 1000);
				const timeString = date.toLocaleString();
				const relativeTime = formatRelativeTime(note.timestamp);
				
				const authorDisplay = note.displayName || (note.pubkey ? note.pubkey.slice(0, 8) + "..." : note.author);
				
				const noteHeader = document.createElement('div');
				noteHeader.className = 'note-header';

				const authorStrong = document.createElement('strong');
				authorStrong.className = 'author-name';
				authorStrong.setAttribute('data-pubkey', note.pubkey || '');
				authorStrong.textContent = authorDisplay; 

				const timeSpan = document.createElement('span');
				timeSpan.className = 'note-time';
				timeSpan.textContent = `${relativeTime} (${timeString})`;

				noteHeader.appendChild(authorStrong);
				noteHeader.appendChild(timeSpan);

				const noteContentDiv = document.createElement('div');
				noteContentDiv.className = 'note-content';

				// NEW: Validate and limit content length
				const maxContentLength = 100000; // 100KB limit
				let safeContent = note.content;
				if (typeof safeContent !== 'string') {
					safeContent = '[Invalid content type]';
				} else if (safeContent.length > maxContentLength) {
					safeContent = safeContent.slice(0, maxContentLength) + '... [content truncated for security]';
				}

				// Handle long content with expand/collapse
				if (safeContent.length > 250) {
					const shortContent = safeContent.slice(0, 250);
					const fullContent = safeContent;
					
					// Clear the content div
					noteContentDiv.innerHTML = '';
					
					// Create short content span
					const shortSpan = document.createElement('span');
					shortSpan.className = 'note-short';
					
					// Add the short content safely
					const shortContentElement = escapeHtml(shortContent + '... ');
					shortSpan.appendChild(shortContentElement);
					
					// Create "show more" button
					const showMoreBtn = document.createElement('button');
					showMoreBtn.textContent = 'show more';
					showMoreBtn.style.cssText = 'background:none; border:none; color:var(--accent-orange); cursor:pointer; padding:0; font-size:14px;';
					showMoreBtn.addEventListener('click', function() {
						shortSpan.style.display = 'none';
						fullSpan.style.display = 'block';
					});
					
					shortSpan.appendChild(showMoreBtn);
					
					// Create full content span
					const fullSpan = document.createElement('span');
					fullSpan.className = 'note-full';
					fullSpan.style.display = 'none';
					
					// Add the full content safely
					const fullContentElement = escapeHtml(fullContent + ' ');
					fullSpan.appendChild(fullContentElement);
					
					// Create "show less" button
					const showLessBtn = document.createElement('button');
					showLessBtn.textContent = 'show less';
					showLessBtn.style.cssText = 'background:none; border:none; color:var(--accent-orange); cursor:pointer; padding:0; font-size:14px;';
					showLessBtn.addEventListener('click', function() {
						fullSpan.style.display = 'none';
						shortSpan.style.display = 'block';
					});
					
					fullSpan.appendChild(showLessBtn);
					
					// Add both spans to the content div
					noteContentDiv.appendChild(shortSpan);
					noteContentDiv.appendChild(fullSpan);
					
				} else {
					// Clear the content div first
					noteContentDiv.innerHTML = '';
					
					// Add the content safely
					const safeContentElement = escapeHtml(safeContent);
					noteContentDiv.appendChild(safeContentElement);
				}

				noteElement.appendChild(noteHeader);
				noteElement.appendChild(noteContentDiv);

				// Process images after adding the note to DOM
				processImagesInContent(safeContent, noteElement);
				
				container.appendChild(noteElement);
			});
			
			// Only fetch usernames if we don't have them yet
			if (fetchUsernames) {
				setTimeout(() => {
					fetchAndUpdateUsernames();
				}, 100);
			}
		}

		function openHelpModal() {
			document.getElementById('helpModal').style.display = 'block';
		}

		function closeHelpModal() {
			document.getElementById('helpModal').style.display = 'none';
		}

        function updateThemeIcon() {
            const themeBtn = document.getElementById('themeBtn');
            const currentTheme = document.body.getAttribute('data-theme') || 'light';
            
            if (currentTheme === 'dark') {
                themeBtn.textContent = 'üåô';
            } else if (currentTheme === 'clown') {
                themeBtn.textContent = 'ü§°';
            } else if (currentTheme === 'light') {
                themeBtn.textContent = '‚òÄÔ∏è';
            }
        }

		function toggleTheme() {
			const body = document.body;
			const currentTheme = body.getAttribute('data-theme') || 'light';
			
			let newTheme;
			if (currentTheme === 'light') {
				newTheme = 'dark';
			} else if (currentTheme === 'dark') {
				newTheme = 'clown';
			} else {
				newTheme = 'light';
			}
			
			body.setAttribute('data-theme', newTheme);
			localStorage.setItem('theme', newTheme);
			updateThemeIcon();
		}

		async function fetchAndUpdateUsernames() {
			if (isLookingUpUsernames) {
				return;
			}
			
			// Skip if slow connection is checked
			if (document.getElementById('slowConnection').checked) {
				logToConsole("‚ö° Skipping usernames - slow connection mode");
				return;
			}
			
			logToConsole("üë§ Starting username lookups...");
			isLookingUpUsernames = true;
			
			// Get all unique pubkeys from current feed that don't have display names yet
			const pubkeysToFetch = [...new Set(currentFeed
				.filter(note => !note.displayName) // Only fetch if we don't have it
				.map(note => note.pubkey)
				.filter(Boolean)
			)];
			
			if (pubkeysToFetch.length === 0) {
				isLookingUpUsernames = false;
				return;
			}
			
			logToConsole(`üîç Looking up ${pubkeysToFetch.length} unique authors`);
			
			// Try to reuse existing connection, otherwise create new one
			let relay = null;
			let shouldCloseRelay = false;

			if (window.lastWorkingRelay && 
				window.lastWorkingRelay.readyState === WebSocket.OPEN && 
				window.lastRelayUrl && 
				window.lastRelayUrl.includes('damus.io')) {
				
				logToConsole("‚ôªÔ∏è Reusing existing relay connection for profiles");
				relay = window.lastWorkingRelay;
				shouldCloseRelay = false; // Don't close shared connection
			} else {
				logToConsole("üîå Creating new relay connection for profiles");
				relay = new WebSocket('wss://relay.damus.io');
				shouldCloseRelay = true; // Close our own connection when done
			}

			const sendProfileRequest = function() {
				logToConsole("üë§ Requesting profiles");
				
				// Request profiles (kind 0 events)
				const profileRequest = [
					"REQ",
					"get-profiles",
					{
						"kinds": [0],
						"authors": pubkeysToFetch,
						"limit": pubkeysToFetch.length
					}
				];
				
				relay.send(JSON.stringify(profileRequest));
			};

			if (relay.readyState === WebSocket.OPEN) {
				sendProfileRequest();
			} else {
				relay.onopen = sendProfileRequest;
			}
			
			relay.onmessage = function(event) {
				const message = JSON.parse(event.data);
				
				if (message[0] === "EVENT" && message[2].kind === 0) {
					const profileData = message[2];
					const pubkey = profileData.pubkey;
					
					try {
						// NEW: Validate content before parsing
						if (!profileData.content || typeof profileData.content !== 'string') {
							logToConsole("Invalid profile content format", 'error');
							return;
						}

						// NEW: Limit content size before parsing
						if (profileData.content.length > 10000) {
							logToConsole("Profile content too large, skipping", 'warn');
							return;
						}

						const profile = JSON.parse(profileData.content);
						
						// NEW: Validate profile is an object
						if (!profile || typeof profile !== 'object') {
							logToConsole("Invalid profile data format", 'error');
							return;
						}
						
						// Sanitize display name - only allow safe characters
						let rawDisplayName = profile.display_name || profile.name || '';
						
						// NEW: Ensure it's a string
						if (typeof rawDisplayName !== 'string') {
							rawDisplayName = '';
						}
						
						// Remove any HTML tags and dangerous characters
						rawDisplayName = rawDisplayName.replace(/<[^>]*>/g, ''); // Strip HTML
						rawDisplayName = rawDisplayName.replace(/[<>&"']/g, ''); // Remove dangerous chars
						rawDisplayName = rawDisplayName.trim();
						
						// Limit length to prevent UI issues
						if (rawDisplayName.length > 50) {
							rawDisplayName = rawDisplayName.slice(0, 50) + '...';
						}
						
						// Use sanitized name or fallback
						const displayName = rawDisplayName || pubkey.slice(0, 8) + "...";
						
						// Validate avatar URL
						let safeAvatarUrl = null;
						if (profile.picture && typeof profile.picture === 'string') {
							try {
								const url = new URL(profile.picture);
								if (url.protocol === 'https:' || url.protocol === 'http:') {
									safeAvatarUrl = profile.picture;
								}
							} catch (e) {
								// Invalid URL - ignore silently
							}
						}
						
						logToConsole(`üë§ Found name: ${displayName} for ${pubkey.slice(0, 8)}...`);
						
						// UPDATE THE NOTES DATA
						currentFeed.forEach(note => {
							if (note.pubkey === pubkey) {
								note.displayName = displayName;
								note.avatar = safeAvatarUrl;
							}
						});
						
						// UPDATE ONLY THE DOM ELEMENTS for this pubkey - batch DOM updates for better performance
						const authorElements = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);

						// Use DocumentFragment to batch DOM changes
						const fragment = document.createDocumentFragment();
						let needsFragmentUpdate = false;

						authorElements.forEach(element => {
							// Update the text content
							element.textContent = displayName;
							
							// Add avatar if we have one and not in slow connection mode
							if (safeAvatarUrl && !document.getElementById('slowConnection').checked && !element.querySelector('img')) {
								loadProfileImage(safeAvatarUrl, element, pubkey);
							}
						});
						
					} catch (e) {
						logToConsole("‚ö† Failed to parse profile for " + pubkey.slice(0, 8));
					}
				}
				
				if (message[0] === "EOSE") {
					logToConsole("‚úÖ Done fetching profiles");
					if (shouldCloseRelay) {
						relay.close();
					}
					isLookingUpUsernames = false;
				}
			};
			
			relay.onerror = function(error) {
				logToConsole("‚ùå Profile lookup failed: " + error);
				if (shouldCloseRelay) {
					relay.close();
				}
				isLookingUpUsernames = false;
			};
		}

		function showDefaultFeedInfo() {
			const container = document.getElementById('feedContainer');
			const infoDiv = document.createElement('div');
			infoDiv.style.cssText = 'background: #dbeafe; border: 1px solid #3b82f6; padding: 12px; margin-bottom: 16px; border-radius: 6px; font-size: 14px;';
			infoDiv.setAttribute('data-demo-alert', 'true');
			
			const strongText = document.createElement('strong');
			strongText.textContent = "You're viewing a demo feed!";
			
			const br = document.createElement('br');
			
			const description = document.createTextNode('This shows recent notes from people followed by a Nostr vibecoder who tries to follow real, interesting people. That said, NOSTR is uncensored, so use at your own risk, and be careful clicking links.');
			
			const learnBtn = document.createElement('button');
			learnBtn.textContent = 'Learn More';
			learnBtn.style.cssText = 'padding: 2px 6px; border: none; background: #3b82f6; color: white; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 4px; min-height: auto;';
			learnBtn.onclick = openHelpModal;

			const dismissBtn = document.createElement('button');
			dismissBtn.textContent = 'Dismiss';
			dismissBtn.style.cssText = 'padding: 2px 6px; border: none; background: #6b7280; color: white; border-radius: 4px; cursor: pointer; font-size: 12px; min-height: auto;';
			dismissBtn.onclick = function() { infoDiv.remove(); };

			const buttonContainer = document.createElement('div');
			buttonContainer.style.cssText = 'margin-top: 8px;';
			buttonContainer.appendChild(learnBtn);
			buttonContainer.appendChild(dismissBtn);

			infoDiv.appendChild(strongText);
			infoDiv.appendChild(br);
			infoDiv.appendChild(description);
			infoDiv.appendChild(buttonContainer);
			
			// Insert at the top of the feed container
			container.insertBefore(infoDiv, container.firstChild);
		}

		function formatRelativeTime(timestamp) {
			const now = Math.floor(Date.now() / 1000);
			const diff = now - timestamp;
			
			if (diff < 60) return 'just now';
			if (diff < 3600) return Math.floor(diff / 60) + ' minutes ago';
			if (diff < 86400) return Math.floor(diff / 3600) + ' hours ago';
			if (diff < 604800) return Math.floor(diff / 86400) + ' days ago';
			return Math.floor(diff / 604800) + ' weeks ago';
		}

		function shortenLongStrings(text) {
			// Skip content inside HTML tags and only process plain text
			return text.replace(/([^<]*?)(<[^>]*>)/g, function(match, textPart, htmlPart) {
				const shortenedText = textPart.replace(/\b[a-zA-Z0-9]{20,}\b/g, function(longString) {
					// Skip if it's already a known nostr identifier
					if (longString.startsWith('npub1') || longString.startsWith('note1') || 
						longString.startsWith('nevent1') || longString.startsWith('nprofile1')) {
						return longString;
					}
					return longString.slice(0, 12) + '...';
				});
				return shortenedText + htmlPart;
			});
		}

		function loadProfileImage(imageUrl, authorElement, pubkey) {
			// Validate URL first
			try {
				const url = new URL(imageUrl);
				if (url.protocol !== 'https:' && url.protocol !== 'http:') {
					return; // Skip invalid protocols
				}
			} catch (e) {
				return; // Skip invalid URLs
			}
			
			// Check file size with HEAD request before downloading
			fetch(imageUrl, { 
				method: 'HEAD',
				signal: AbortSignal.timeout(1200) // 1.2 second timeout
			})
			.then(response => {
				const contentLength = response.headers.get('content-length');
				
				if (contentLength && parseInt(contentLength) > 300000) {
					logToConsole(`Avatar too large: ${Math.round(contentLength/1000)}kb`, 'warn');
					return;
				}
				
				// Size is acceptable, now create and load the avatar
				const avatar = document.createElement('img');
				avatar.src = imageUrl;
				avatar.style.cssText = 'width: 50px; height: 50px; border-radius: 50%; margin-right: 8px; vertical-align: middle;';
				avatar.alt = 'Profile photo';
				avatar.crossOrigin = 'anonymous';
				avatar.referrerPolicy = 'no-referrer';
				avatar.loading = 'lazy';
				
				avatar.onerror = function() { 
					this.style.display = 'none'; 
					this.remove();
				};
				
				// Insert before the name text
				authorElement.insertBefore(avatar, authorElement.firstChild);
			})
			.catch(error => {
				// Fail silently - network errors or timeouts are expected
				logToConsole(`Avatar check failed: ${error.message}`, 'warn');
			});
		}

		function escapeHtml(text) {
			// Input validation and length limits
			if (typeof text !== 'string') {
				return document.createTextNode('[Invalid content type]');
			}
			
			if (text.length > 50000) {
				text = text.substring(0, 50000) + '... [content truncated for security]';
			}
			
			// Create a container div to hold all content
			const container = document.createElement('div');
			
			// Whitelist of allowed domains with their labels
			const allowedDomains = {
				'youtube.com': 'video',
				'youtu.be': 'video',
				'twitter.com': 'social',
				'x.com': 'social',
				'instagram.com': 'social',
				'tiktok.com': 'video',
				'reddit.com': 'social',
				'linkedin.com': 'social',
				'imgur.com': 'image',
				'giphy.com': 'image',
				'nostr.build': 'image',
				'github.com': 'dev',
				'gitlab.com': 'dev',
				'njump.me': 'nostr',
				'nostr.band': 'nostr',
				'nostrudel.ninja': 'nostr',
				'spotify.com': 'music',
				'soundcloud.com': 'music',
				'tidal.com': 'music',
				'blossom.primal.net': 'media',
				'cornychat.com': 'audio conference',
				'hivetalk.org': 'video conference',
				'zap.stream': 'livestream video',
				'fountain.fm': 'media',
				'nostrmedia.com': 'media'
			};
			
			// Simple URL regex - only matches http/https
			const urlRegex = /(https?:\/\/[^\s<>"'\[\]{}|\\^`]+)/gi;
			const parts = text.split(urlRegex);
			
			for (let i = 0; i < parts.length; i++) {
				const part = parts[i];
				
				if (part.match(urlRegex)) {
					try {
						const urlObj = new URL(part);
						
						// Only allow HTTP/HTTPS
						if (urlObj.protocol !== 'https:' && urlObj.protocol !== 'http:') {
							const textNode = document.createTextNode(part);
							container.appendChild(textNode);
							continue;
						}
						
						// Safety checks
						if (urlObj.hostname.length > 100 || part.length > 2000) {
							const textNode = document.createTextNode('[suspicious URL blocked]');
							container.appendChild(textNode);
							continue;
						}
						
						// Create link element
						const linkElement = document.createElement('a');
						linkElement.href = part;
						linkElement.target = '_blank';
						linkElement.rel = 'noopener noreferrer';
						linkElement.style.color = 'var(--accent-orange)';
						linkElement.style.textDecoration = 'underline';
						
						// Check if domain is in whitelist
						const domain = urlObj.hostname.replace(/^www\./, '').toLowerCase();
						let linkType = 'unknown web';
						
						for (const [allowedDomain, label] of Object.entries(allowedDomains)) {
							if (domain === allowedDomain || domain.endsWith('.' + allowedDomain)) {
								linkType = label;
								break;
							}
						}
						
						// Set display text
						linkElement.textContent = `${domain}/[${linkType}]`;
						container.appendChild(linkElement);
						
					} catch (e) {
						// If URL parsing fails, show as plain text
						const textNode = document.createTextNode(part);
						container.appendChild(textNode);
					}
				} else {
					// Handle nostr identifiers
					const nostrRegex = /(npub1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}|note1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}|nevent1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{10,}|nprofile1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{10,})/g;
					const nostrParts = part.split(nostrRegex);
					
					for (let j = 0; j < nostrParts.length; j++) {
						const nostrPart = nostrParts[j];
						
						if (nostrPart.match(nostrRegex)) {
							if (nostrPart.length > 200) {
								const textNode = document.createTextNode('[nostr ID too long]');
								container.appendChild(textNode);
								continue;
							}
							
							const nostrLink = document.createElement('a');
							nostrLink.href = `https://njump.me/${nostrPart}`;
							nostrLink.target = '_blank';
							nostrLink.rel = 'noopener noreferrer';
							nostrLink.style.color = 'var(--accent-orange)';
							nostrLink.style.textDecoration = 'underline';
							nostrLink.textContent = nostrPart.substring(0, nostrPart.indexOf('1') + 2) + '...';
							
							container.appendChild(document.createTextNode('\u00A0'));
							container.appendChild(nostrLink);
						} else {
							// Regular text - shorten very long strings
							let processedText = nostrPart.replace(/\b[a-zA-Z0-9]{25,}\b/g, function(longString) {
								if (longString.startsWith('npub1') || longString.startsWith('note1') || 
									longString.startsWith('nevent1') || longString.startsWith('nprofile1')) {
									return longString;
								}
								return longString.slice(0, 15) + '...';
							});
							
							const textNode = document.createTextNode(processedText);
							container.appendChild(textNode);
						}
					}
				}
			}
			
			return container;
		}

        function setLoading(loading) {
            isLoading = loading;
            const container = document.getElementById('feedContainer');
			if (loading) {
				// Clear container but preserve demo alert if we're still on demo feed
				const existingDemoAlert = container.querySelector('[data-demo-alert="true"]');
				const shouldPreserveDemoAlert = existingDemoAlert && 
					currentType === 'npub' && 
					currentValue === 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc';

				// Fast clear with fallback for older browsers
				if (container.replaceChildren) {
					container.replaceChildren();
				} else {
					while (container.firstChild) {
						container.removeChild(container.firstChild);
					}
				}

				// Put demo alert back if we should preserve it
				if (shouldPreserveDemoAlert) {
					container.appendChild(existingDemoAlert);
				}
				
				// Create loading div
				const loadingDiv = document.createElement('div');
				loadingDiv.className = 'loading';
				loadingDiv.textContent = 'Loading notes...';
				container.appendChild(loadingDiv);
			}
        }

		function showError(message) {
			const container = document.getElementById('feedContainer');
			
			// Clear container but preserve demo alert if we're still on demo feed
			const existingDemoAlert = container.querySelector('[data-demo-alert="true"]');
			const shouldPreserveDemoAlert = existingDemoAlert && 
				currentType === 'npub' && 
				currentValue === 'npub1v89nr2zax8ef0ceyu9te0sjyqv3newa3e82m0rd4kye3ekeyhv2sqf30cc';

			// Fast clear with fallback for older browsers
			if (container.replaceChildren) {
				container.replaceChildren();
			} else {
				while (container.firstChild) {
					container.removeChild(container.firstChild);
				}
			}

			// Put demo alert back if we should preserve it
			if (shouldPreserveDemoAlert) {
				container.appendChild(existingDemoAlert);
			}

			const errorDiv = document.createElement('div');
			errorDiv.className = 'error';
			errorDiv.textContent = message;
			container.appendChild(errorDiv);
		}

        // Handle Enter key in input
		document.getElementById('npubInput').addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				// NEW: Basic input validation before processing
				const value = this.value.trim();
				if (value.length > 200) {
					showMessageBanner("Input too long", 3000);
					return;
				}
				loadFeed();
			}
		});

		// Close modal when clicking outside
		window.addEventListener('click', function(event) {
			// NEW: Validate event and target exist
			if (!event || !event.target) {
				return;
			}
			
			const modal = document.getElementById('settingsModal');
			if (event.target === modal) {
				closeSettings();
			}
		});
		
		// Handle slow connection checkbox changes
		document.getElementById('slowConnection').addEventListener('change', function() {
			const consoleBanner = document.getElementById('consoleBanner');
			
			if (this.checked) {
				logToConsole("Slow connection mode enabled");
				consoleBanner.classList.remove('show');
				showMessageBanner("Slow connection mode enabled.  To save bandwidth, fewer notes, no avatars are fetched, and usernames not resolved", 6000);
				
			} else {
				consoleBanner.classList.add('show');
				
				showMessageBanner("Slow connection mode disabled", 3000);
			}
		});

		// Handle selector change
		document.getElementById('savedSelector').addEventListener('change', function() {
			if (this.value) {
				// NEW: Validate selected value before using it
				const value = this.value.trim();
				if (value.length < 2000 && (value.startsWith('npub1') || value.startsWith('wss://') || value.startsWith('ws://'))) {
					document.getElementById('npubInput').value = value;
				} else {
					this.value = ''; // Reset selector if invalid
					showMessageBanner("Invalid selection detected", 3000);
				}
			}
		});

		// Handle close button click
		document.addEventListener('DOMContentLoaded', function() {
			document.getElementById('bannerClose').addEventListener('click', hideBanner);
		});

		// Handle sort order change
		document.getElementById('sortOrder').addEventListener('change', function() {
			logToConsole("Sort order changed to: " + this.value);
			if (currentFeed.length > 0) {
				logToConsole("Re-displaying " + currentFeed.length + " notes");
				displayFeed(currentFeed, false);
			} else {
				logToConsole("No notes to re-sort");
			}
		});
	</script>
</body>
</html>
